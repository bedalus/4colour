"""
Utility to analyze function call logs generated by function_logger.py.

This script processes the key and call logs to produce meaningful insights
about function call patterns in the application.
"""

import os
import pandas as pd
import matplotlib.pyplot as plt
from collections import Counter, defaultdict

def load_key_log(filename="function_key_log.txt"):
    """Load the key log file into a dictionary.
    
    Args:
        filename: Path to the key log file
        
    Returns:
        dict: Mapping of function IDs to function names
    """
    id_to_name = {}
    try:
        # Read the CSV file (skip header)
        df = pd.read_csv(filename)
        # Convert to dictionary
        for _, row in df.iterrows():
            id_to_name[row['ID']] = row['FUNCTION_NAME']
        return id_to_name
    except Exception as e:
        print(f"Error loading key log: {e}")
        return {}

def load_call_log(filename="function_call_log.txt"):
    """Load the call log file into a DataFrame.
    
    Args:
        filename: Path to the call log file
        
    Returns:
        DataFrame: Call log data
    """
    try:
        return pd.read_csv(filename)
    except Exception as e:
        print(f"Error loading call log: {e}")
        return pd.DataFrame(columns=['TIMESTAMP', 'CALLER_ID', 'CALLEE_ID'])

def generate_call_graph(calls_df, id_to_name):
    """Generate a call graph from the call log data.
    
    Args:
        calls_df: DataFrame containing call log data
        id_to_name: Dictionary mapping function IDs to names
        
    Returns:
        dict: Call graph as an adjacency list
    """
    call_graph = defaultdict(set)
    
    for _, row in calls_df.iterrows():
        caller_id = row['CALLER_ID']
        callee_id = row['CALLEE_ID']
        
        if caller_id > 0:  # Skip calls without a valid caller
            call_graph[caller_id].add(callee_id)
    
    return call_graph

def count_function_calls(calls_df):
    """Count the number of calls for each function.
    
    Args:
        calls_df: DataFrame containing call log data
        
    Returns:
        Counter: Mapping of function IDs to call counts
    """
    return Counter(calls_df['CALLEE_ID'])

def display_most_called_functions(call_counts, id_to_name, top_n=20):
    """Display the most frequently called functions.
    
    Args:
        call_counts: Counter mapping function IDs to call counts
        id_to_name: Dictionary mapping function IDs to names
        top_n: Number of top functions to display
    """
    print("\nMost Called Functions:")
    print("---------------------")
    
    for func_id, count in call_counts.most_common(top_n):
        func_name = id_to_name.get(func_id, f"Unknown({func_id})")
        print(f"{func_name}: {count} calls")
    
    # Optional: Generate a bar chart
    if call_counts:
        top_funcs = call_counts.most_common(top_n)
        func_ids, counts = zip(*top_funcs)
        func_names = [id_to_name.get(fid, f"ID:{fid}")[-30:] for fid in func_ids]
        
        plt.figure(figsize=(12, 8))
        plt.barh(range(len(func_names)), counts, align='center')
        plt.yticks(range(len(func_names)), func_names)
        plt.xlabel('Number of Calls')
        plt.title('Most Frequently Called Functions')
        plt.tight_layout()
        plt.savefig('most_called_functions.png')
        print(f"Chart saved to most_called_functions.png")

def display_call_chains(call_graph, id_to_name, min_depth=3):
    """Display common call chains in the application.
    
    Args:
        call_graph: Call graph as an adjacency list
        id_to_name: Dictionary mapping function IDs to names
        min_depth: Minimum depth of chains to display
    """
    print("\nCommon Call Chains:")
    print("------------------")
    
    def find_chains(node, current_chain=None):
        if current_chain is None:
            current_chain = []
        
        # Add current node to chain
        current_chain.append(node)
        
        # If chain is long enough, record it
        if len(current_chain) >= min_depth:
            chain_str = " -> ".join(id_to_name.get(n, f"ID:{n}") for n in current_chain)
            print(chain_str)
        
        # Follow the call graph (limited depth to avoid cycles)
        if len(current_chain) < 10:  # Limit to prevent infinite recursion
            for callee in call_graph.get(node, []):
                if callee not in current_chain:  # Avoid cycles
                    find_chains(callee, current_chain.copy())
    
    # Start with root functions (those with no callers)
    all_callees = set()
    for callees in call_graph.values():
        all_callees.update(callees)
    
    root_functions = set(call_graph.keys()) - all_callees
    if not root_functions:
        # If no clear roots, use functions that are called most
        root_functions = set(call_graph.keys())
    
    # Find chains starting from each root
    for root in root_functions:
        find_chains(root)

def main():
    """Main function to analyze call logs."""
    print("Function Call Log Analyzer")
    print("=========================")
    
    # Check if log files exist
    key_log_path = "function_key_log.txt"
    call_log_path = "function_call_log.txt"
    
    if not os.path.exists(key_log_path) or not os.path.exists(call_log_path):
        print(f"Log files not found. Please run the application first.")
        return
    
    # Load log data
    id_to_name = load_key_log(key_log_path)
    calls_df = load_call_log(call_log_path)
    
    if not id_to_name or calls_df.empty:
        print("Log data is empty. No analysis to perform.")
        return
    
    print(f"Loaded {len(id_to_name)} function definitions and {len(calls_df)} call records.")
    
    # Analyze data
    call_counts = count_function_calls(calls_df)
    call_graph = generate_call_graph(calls_df, id_to_name)
    
    # Display results
    display_most_called_functions(call_counts, id_to_name)
    #display_call_chains(call_graph, id_to_name)
    
    print("\nAnalysis complete!")

if __name__ == "__main__":
    main()
